# Сервис хранения интернет-закладок
Многопользовательский сервис предоставляет REST API для управления интернет-закладками. Написан на Java с использованием SpringBoot.

## Сборка, запуск и тестирование приложения
Сборка проекта может быть осуществлена командой
```shell
./gradlew assemble
```
Для запуска приложения воспользуйтесь командой. Приложение поднимается на порту 8080 по-умолчанию:
```shell
./gradlew bootRun
```

Для запуска тестов и верификации покрытия кода тестами запустите команду
```shell
./gradlew test
```

## Описание функциональности
Основные функции сервиса:
- Регистрация пользователя (по логину и паролю) (`http://localhost:8080/account`)
- Аутентификация пользователя по логину и паролю с выдачей JWT (`http://localhost:8080/auth`)
- Создание закладки с указанием URL страницы (`http://localhost:8080/bookmark`)
  - при сохранении закладки производится считывание заголовка страницы и сохранение закладки вместе с заголовком
  - при сохранении закладки есть возможность назначить тэг
- Просмотр закладок (`http://localhost:8080/bookmark`)
  - просмотр всех закладок
  - просмотр одной конкретной закладки
  - просмотр всех закладок под определенным тэгом
  - просмотр всех закладок без тэга
  - задание порядка отображения закладок по:
    - заголовку страницы
    - URL страницы
    - дате добавления
- Удаление закладки (`http://localhost:8080/bookmark`)
- Удаление аккаунта (`http://localhost:8080/account`)

## Авторизация пользователя
Пользователь передает логин и пароль, использованные при регистрации, в endpoint /auth в POST запросе. В ответ от сервера приходит JSON, хранящий JWT (JSON Web Token). Значение токена необходимо поместить в авторизационный заголовок при последующих запросах на управление закладками и удаления аккаунта. 

Пример авторизационного заголовка с JWT:
```yaml
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJzb21lQGV4YW1wbGUuY29tIiwiZXhwIjoxNjU5MzEzNTU4LCJpYXQiOjE2NTkyOTU1NTh9.GveD-m5p1Y6e7A15KySDRx5xuqq-PGH8YcBYrYpVOGGTuG8U3YVJ5ZOHQ9_m_JEGkl98DGSc0FLknUXyndmb4g
```

## Формальное описание API
Интерфейс (REST API) сервиса формализовано в openAPI описании в файле [src/main/resources/MyBookmarks.yaml](src/main/resources/MyBookmarks.yaml).
В openAPI описании учтены коды ответов и возможные входные и выходные сообщения в каждый endpoint.

## Хранение данных
Управление пользовательскими данными производится в in-memory базе данных H2 через механизм Java Persistence API (JPA via Hibernate).

Персистентность от запуска к запуску обеспечивается настройкой `DB_CLOSE_ON_EXIT=FALSE` в строке подключения в файле `application.properties`.
При желании можно выбрать другую БД, изменив настройки приложения и подключив соответствующие зависимости.

## Подключение Lombok
В проекте используется annotation processor Lombok, который избавляет от необходимости писать геттеры, сеттеры и другой boilerplate код посредством добавления аннотаций на методы и классы. Для корректного отображения подобных аннотированных классов в среде разработки требуется подключить соответствующий плагин для вашей IDE. Например, для IDEA процесс подключения описан на странице проекта [projectlombok.org/setup/intellij](https://projectlombok.org/setup/intellij).

## Верификация покрытия кода тестами
В проекте подключен плагин автоматической проверки покрытия кода тестами jacoco. Критерии успешной верификации указаны в файле [build.gradle](build.gradle). В случае неудовлетворения данным критериям сборка будет зафейлина с пояснением причины. Детализацию причины можно исследовать в отчете.

При запуске тестов плагин jacoco формирует html-отчет в файле [build/reports/jacoco/test/html/index.html](build/reports/jacoco/test/html/index.html). Его можно открыть в браузере и посмотреть какие строки кода были покрыты тестами, а какие остались неисполненными.

Подробнее с работой верификации можно ознакомиться на странице проекта [jacoco](https://www.jacoco.org/jacoco/) или в туториале [JaCoCo code coverage example](https://mkyong.com/maven/maven-jacoco-code-coverage-example/)

## Задание
Задание состоит из нескольких этапов от погружения в проект с помощью настройки и исправления багов в коде до разработки новой функциональности с проектированием и тестированием разных видов.

---

**ВАЖНО:**

Каждый этап предполагает написание отчета - его необходимо писать в README.md вашего проекта и его же необходимо передавать на проверку. В отчете для каждого этапа должна быть постановка задачи, решение (ссылки на MergeRequest, issue, текстовое описание того, что было сделано), вывод - summary выполненной работы по этапу.

---

### Погружение в проект
Научитесь собирать проект и запускать тесты. Сделайте форк (fork) проекта в собственный репозиторий.

Сделайте свой репозиторий приватным и добавьте ревьюера (преподавателя) в число разработчиков, чтобы он имел доступ к MergeRequest и к коду репозитория.

Настройте CI в проекте gitlab. Для этого добавьте файл .gitlab-ci.yml в корень проекта.

```yaml
image: gradle:jdk17-focal

stages:          # List of stages for jobs, and their order of execution
  - build
  - test
  - deploy

before_script:
  - export GRADLE_USER_HOME=`pwd`/.gradle

build-job:       # This job runs in the build stage, which runs first.
  stage: build
  script:
    - echo "Compiling the code..."
    - ./gradlew assemble
    - echo "Compile complete."

unit-test-job:   # This job runs in the test stage.
  stage: test    # It only starts when the job in the build stage completes successfully.
  script:
    - echo "Running unit tests... This will take about 60 seconds."
    - ./gradlew test
    - echo "Code coverage is 90%"

lint-test-job:   # This job also runs in the test stage.
  stage: test    # It can run at the same time as unit-test-job (in parallel).
  script:
    - echo "Linting code... This will take about 10 seconds."
    - sleep 1
    - echo "No lint issues found."

deploy-job:      # This job runs in the deploy stage.
  stage: deploy  # It only runs when *both* jobs in the test stage complete successfully.
  environment: production
  script:
    - echo "Deploying application..."
    - echo "Application successfully deployed."
```

Исправьте ошибку **ISSUE-1**.
___
**ISSUE-1**: **[MAJOR]** _HTTP 500 при запросе bookmark по несуществующему id_

Шаги воспроизведения:
1. Зарегистрировать нового пользователя через POST http://localhost:8080/register
2. Аутентифицировать нового пользователя через POST http://localhost:8080/auth
3. Запросить несуществующий bookmark через GET http://localhost:8080/bookmark/123

**Ожидаемое поведение:**
В ответ вернется HTTP код 404 - ресурс не найден

**Фактическое поведение:**
В ответ приходит HTTP код 500 - серверная ошибка
___

### Покрытие кода тестами

Изучите код приложения и напишите ***модульные*** и ***интеграционные (API)*** тесты на все опубликованные эндпоинты. Пример теста эндпоинта `/ping` размещен в папке [src/test](src/test/java).

**Внимание:** в коде могут быть (highly likely) ошибки бизнес-логики и безопасности. Необходимо их обнаружить и исправить.

Необходимо добиться покрытия кода тестами минимум на 70%, но чем больше, тем лучше. Язык тестов - java или groovy. Однако помните, что 100% покрытие кода тестами еще не говорит о качестве самих тестов. Сначала проверяйте самый очевидный успешный пользовательский сценарий, потом пишите негативные проверки и используйте проверки на граничные значения. 

В работе можно использовать любые фреймворки и библиотеки, помогающие с тестированием.

При написании кода тестов, старайтесь чтобы он был лаконичен. Пишите вспомогательные классы для этого, если потребуется.

Обязательные требования:
1. Напишите модульные тесты как минимум на `UserService.validateEmail()`;
2. Напишите интеграционные тесты на все http API, имеющиеся в проекте;
3. Используйте Mockito для исключения работы `UrlTitleFetcher` в некоторых тестовых сценариях.
4. При обнаружении ошибок в коде сервиса, зафиксируйте их в отчете о тестировании (заведите issue в своем репозитории, укажите критичность - см. [bug-severity](https://www.software-testing.by/blog/bug-severity/), заголовок issue должен начинаться с уровня критичности, например: _"[MINOR] Валидация некорректного email fff@fff проходит успешно"_).
5. Исправьте обнаруженные ошибки и добейтесь "зеленых" тестов. Исправление каждой ошибки делайте через создание MergeRequest в **свой** репозиторий и последующий мерж в **свой** мастер.

Ссылки на MergeRequest'ы с исправлением найденных ошибок передайте на проверку ревьюеру.

### Разработка frontend
Необходимо разработать легковесный фротненд, который может взаимодействовать с REST сервисом. Можно использовать любые инструменты и фреймворки.

Фронт должен решать основные задачи пользователя:
1. Регистрация
2. Аутентификация
3. Просмотр всех закладок (с фильтрами и сортировкой)
4. Просмотр одной закладки
5. Добавление закладки
6. Удаление закладки
7. Разлогин пользователя
8. Удаление аккаунта пользователя

### End-2-end (системное) тестирование
Напишите UI тест/тесты на основной сценарий использования сервиса со следующими шагами: регистрация, аутентификация, добавление закладки, просмотр закладок.

Используйте любые инструменты для UI тестирования. Предпочтение - [JEST](https://jestjs.io/ru/).

Встройте тестирование в процесс CI.

### Разработка новой функциональности
На лекции мы проследили за процессом, как разрабатывать новые крутые продуктовые фичи в сервисе Такси. Давай реализуем что-то похожее на небольшом проекте.

Представь, что нам необходимо вывести наш сервис MyBookmarks на новый качественный уровень среди подобных продуктов. Надо завоевать долю на рынке и нарастить количество активных пользователей с X до Y %. Это стратегическая цель. Но как ее достичь?

Тебе необходимо реализовать путь фичи от идеи до воплощения. Для начала нужно ее придумать.
1. Описать свою идею в 1-2 предложениях и объяснить, почему она повысит счастье пользователей;
2. Сформулировать продуктовые гипотезы - 1-2 штуки в формате, как было на лекции;
3. Оценить примерные трудозатраты (попробуй аргументировать оценку, например, требуемым количеством новых классов, объемом кода);
4. Придумать, можно ли сделать MVP, если да, то как он будет выглядеть и сколько это займет времени;
5. Проработать архитектуру и описать ее в тексте (в качестве формального описания подойдут openapi описание, диаграммы классов, компонентные диаграммы - в зависимости от того, что лучше отразит суть изменений и, что по твоему мнению будет понятнее ревьюеру);
6. Реализовать полное решение идеи в коде;
7. Придумать AB-тест - какие выборки пользователей будут в эксперименте? Какие параметры фичи (если у нее могут быть параметры) будем проверять в каждой выборке?
8. Выбрать и описать набор наблюдаемых продуктовых метрик, по которым можно сделать вывод, что фича "взлетела". Какие значения метрик ожидаем увидеть?

### Добавление линтеров
Добавьте линтер в gradle сборку. Исправьте в одном или нескольких MergeRequest, все ошибки уровня ERROR и WARNING, которые он обнаружил в коде сервиса.

### Тестирование производительности
Среди многих типов тестирования производительности, таких как тестирование стабильности (stability testing), стресс тестирование (stress testing), тестирование восстановления (recovery testing), тестирование при всплесках нагрузки (spike testing) и др., мы остановимся на одном из самых востребованных - нагрузочном тестировании (load testing).

В качестве генератора нагрузки скачайте [Apache JMeter](https://jmeter.apache.org/).
Определим профиль нагрузки: считаем, что пользователи будут в 10% случаев создавать новые закладки (POST на /bookmarks) и в 90% случаев читать список своих закладок (GET на /bookmarks). Чтобы найти точку разладки и, соответственно, максимальную производительность сервиса, будем считать приемлемым описанный ниже сценарий нагрузочного тестирования.


**Подготовка к тестированию**

Создать пользователя А и добавить ему 100 закладок. Будем использовать его для операций чтения.
Создать пользователя Б.

**Сценарий нагрузочного тестирования**

Необходимо создать такой сценарий, который на каждые 9 запросов на чтение закладок пользователя А будет делать 1 запрос на добавление закладки пользователя Б.

Запустите нагрузочный тест, начиная с небольшой нагрузки в несколько потоков. Увеличивайте нагрузку постепенно до обнаружения точки разладки - появление ошибок и возникновение больших задержек ответов.

**Метрики производительности**

В ходе проведения тестирования измерьте и постройте графики:
1. CPU/RAM, потребляемых сервисом, от времени
2. Входной нагрузки (количество потоков или другая характеристика) от времени
3. Количество ответов в секунду (tps - transaction per second) от времени
4. Среднего/максимального времени ответа от времени

### CD - разворачивание на staging
Исследуйте возможность разворачивания сервиса на тестовой среде в бесплатном облаке, например, в [Microsoft Azure](https://azure.microsoft.com/en-us/pricing/details/app-service/linux/).

Разверните сервис, предпринятые шаги для достижения данной цели.
